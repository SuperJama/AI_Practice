
# 1.1 数据预处理
## 1.1.1 均值移除
### 通过使用sklearn库的preprocessing包<br>
```
preprocessing.scale(data) ///data为需要处理的数据（一般为数组）<br>
.mean(axis=) ///mean为输出均值，axis为维数<br>
.std(axis=) ///std为输出标准差<br>
```
## 1.1.2 范围缩放
### 通过使用sklearn库的preprocessing函数<br>
```
data_scaler = preprocessing.MinMaxScaler(feature_range=(0,1)) ///feature_range为缩放范围<br>
data_scaled = data_scaler.fit_transform(data) ///fit_transform为训练数据和转换数据<br>
```
## 1.1.3 归一化
```
preprocessing.normalize(data, norm='l1') ///norm将特征向量调整到L1范数<br>
.fit_transform(data) ///用法与1.1.2相同
```
## 1.1.4 二值化
```
preprocessing.Binarizer(threshold=1.4).transform(data) ///threshold将数据分割开， 此处x<=1.4为0<br>
```
## 1.1.5 独热编码
```
preprocessing.OneHotEncoder()<br>
.fit(data) ///传入数据<br>
.transform([[x,x,x]]).toarray() /// xxx为需要编码的位置，toarray类型转换<br>
```
# 1.2 标记编码方法
### 通过sklearn库的preprocessing包
#### `创建标记`
```
label_encoder = preprocessing.LabelEncoder() <br>
input_classes = ['audi', 'ford', 'audi', 'toyota', 'ford', 'bmw'] <br>
label_encoder.fit(input_classes) <br>
print "\nClass mapping:" <br>
for i, item in enumerate(label_encoder.classes_): <br>
    print item, '-->', i
```
#### `反编辑`
```
labels = ['toyota', 'ford', 'audi']
encoded_labels = label_encoder.transform(labels)
print "\nLabels =", labels
print "Encoded labels =", list(encoded_labels)
```
# 1.3 创建线性回归器
## 此处仅介绍相关函数的用法
### open()
```
n(filename, ' ') ///filename为文件地址， ' '为相关操作<br>
```
操作有：'r'; 'rb'; 'r+'; 'rb+'; 'w'; 'wb'; 'w+'; 'wb+'; 'a'; 'ab'; 'a+'; 'ab+'; <br> 
### linear_modal(在sklearn库)
```
linear_modal.LinearRegression() ///创建线性回归对象<br>
.fit(X_train, y_train) ///训练数据<br>
.predict(X_test) ///预测
```
# 1.4 计算回归准确性
`平均绝对误差，均方误差，中位数绝对误差越小越好`<br>
`解释方差分，R方得分  越趋近于1越好`<br>
### round()
```
round(data, x)  ///将数据data精确到小数点后两位
```

```
import sklearn.metrics as sm
round(sm.mean_absolute_error(y_test, y_test_pred), 2) ///平均绝对误差
round(sm.mean_squared_error(y_test, y_ test_pred), 2) ///均方误差
round(sm.median_absolute_error(y_ test, y_test_pred),2) ///中位数绝对误差
round(sm.explained_variance_ score(y_test,y_test_pred), 2)  ///解释方差分
round(sm.r2_score(y_test, y_test_pred), 2)  ///R方得分
```

